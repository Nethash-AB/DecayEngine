// Type definitions for Decay Engine Scripting Environment
// Project: Decay Engine
// Definitions by: Nethash <https://nethash.se>
//
// This code was generated by a tool.
// TypingsGenerator Version: 1.0.0.0.
// DecayEngine Versions:
//     - Core 1.0.0.0
//     - NativeJS 1.0.0.0
//     - ModuleSDK 1.0.0.0
//     - OpenGL 1.0.0.0
//     - SDL2 1.0.0.0
//     - TweenExtension 1.0.0.0
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
/* tslint:disable */

/**
 * Contains wrappers for Managed Math classes.
 */
declare namespace ManagedMath {
    /**
     * Represents an Aabb object.
     */
    class Aabb extends ManagedObject {
        /**
         * The position of the minimum bounds of the `Aabb`.
         *
         * @remarks This property is Read-Only.
         */
        public Min: ManagedMath.Vector3;

        /**
         * The position of the maximum bounds of the `Aabb`.
         *
         * @remarks This property is Read-Only.
         */
        public Max: ManagedMath.Vector3;

        /**
         * The Managed Type of the object.
         *
         * @remarks This property is Read-Only.
         */
        public Type: ManagedObjectType;
    }

    /**
     * Represents a SIMD enhanced Quaternion.
     */
    class Quaternion extends ManagedObject {
        /**
         * The `X` component of the `Quaternion`.
         *
         * @remarks This property is Read/Write.
         */
        public X: number;

        /**
         * The `Y` component of the `Quaternion`.
         *
         * @remarks This property is Read/Write.
         */
        public Y: number;

        /**
         * The `Z` component of the `Quaternion`.
         *
         * @remarks This property is Read/Write.
         */
        public Z: number;

        /**
         * The angle component of the `Quaternion` in radians.
         *
         * @remarks This property is Read/Write.
         */
        public W: number;

        /**
         * The euler angles (pitch, yaw, roll) of the `Quaternion` in radians.
         *
         * @remarks This property is Read-Only.
         */
        public EulerAngles: ManagedMath.Vector3;

        /**
         * The conjugate of the `Quaternion`.
         *
         * @remarks This property is Read-Only.
         */
        public Conjugate: ManagedMath.Quaternion;

        /**
         * Returns a new instance of `Quaternion` representing the identity rotation.
         *
         * @remarks This property is Read-Only.
         */
        public static Identity: ManagedMath.Quaternion;

        /**
         * The Managed Type of the object.
         *
         * @remarks This property is Read-Only.
         */
        public Type: ManagedObjectType;

        /**
         * Constructor.
         *
         * @param x - The value of the `X` component of the `Quaternion`.
         * @param y - The value of the `Y` component of the `Quaternion`.
         * @param z - The value of the `Z` component of the `Quaternion`.
         * @param w - The value of the `W` component of the `Quaternion`.
         */
        constructor(x: number, y: number, z: number, w: number);

        /**
         * Constructor.
         *
         * @param axis - The `Vector3` representing the axis of the `Quaternion`.
         * @param w - The angle of the `Quaternion`.
         */
        constructor(axis: ManagedMath.Vector3, w: number);

        /**
         * Returns the axis (x, y, z) and angle (w) of the `Quaternion`.
         *
         * @returns The axis (x, y, z) and angle (w) of the `Quaternion`.
         */
        public ToAxisAngle(): ManagedMath.Vector4;

        /**
         * Returns the length of the `Quaternion`.
         *
         * @returns The length of the `Quaternion`.
         */
        public Length(): number;

        /**
         * Returns the length of the `Quaternion` squared.
         *
         * @returns The length of the `Quaternion` squared.
         */
        public LengthSquared(): number;

        /**
         * Returns a `Quaternion` equal to the rotation represented by the specified euler angles (pitch, yaw roll) in radians.
         *
         * @param value - The euler angles (pitch, yaw, roll) in radians to construct the `Quaternion` with.
         * @returns A new instance of `Quaternion` equal to the rotation represented by the specified euler angles (pitch, yaw roll) in radians.
         */
        public static FromEulerAngles(value: ManagedMath.Vector3): ManagedMath.Quaternion;

        /**
         * Returns a `Quaternion` equal to the rotation represented by the specified axis (world x, y, z) and angle (in radians).
         *
         * @param axis - The axis (world x, y, z) to construct the `Quaternion` with.
         * @param angle - The angle in radians to construct the `Quaternion` with.
         * @returns A new instance of `Quaternion` equal to the rotation represented by the specified axis (world x, y, z) and angle (in radians).
         */
        public static FromAxisAngle(axis: ManagedMath.Vector3, angle: number): ManagedMath.Quaternion;

        /**
         * Returns the specified `Quaternion` in normalized form.
         *
         * @param value - The `Quaternion` to normalize.
         * @returns A new instance of `Quaternion` representing the result of normalizing the specified `Quaternion`.
         */
        public static Normalize(value: ManagedMath.Quaternion): ManagedMath.Quaternion;

        /**
         * Returns the specified `Quaternion` in normalized form.
         *
         * @returns A new instance of `Quaternion` representing the result of normalizing the `Quaternion`.
         */
        public Normalize(): ManagedMath.Quaternion;

        /**
         * Returns the specified `Quaternion` in inverted form.
         *
         * @param value - The `Quaternion` to invert.
         * @returns A new instance of `Quaternion` representing the result of inverting the specified `Quaternion`.
         */
        public static Invert(value: ManagedMath.Quaternion): ManagedMath.Quaternion;

        /**
         * Returns the specified `Quaternion` in inverted form.
         *
         * @returns A new instance of `Quaternion` representing the result of inverting the `Quaternion`.
         */
        public Invert(): ManagedMath.Quaternion;

        /**
         * Adds two `Quaternion`s together.
         *
         * @param left - The first `Quaternion`.
         * @param right - The second `Quaternion`.
         * @returns A new instance of `Quaternion` representing the sum of the specified `Quaternion`s.
         */
        public static Add(left: ManagedMath.Quaternion, right: ManagedMath.Quaternion): ManagedMath.Quaternion;

        /**
         * Adds the specified `Quaternion` to the `Quaternion`.
         *
         * @param right - The second `Quaternion`.
         * @returns A new instance of `Quaternion` representing the sum of the specified `Quaternion`s.
         */
        public Add(right: ManagedMath.Quaternion): ManagedMath.Quaternion;

        /**
         * Subtracts the second `Quaternion` from the first.
         *
         * @param left - The first `Quaternion`.
         * @param right - The second `Quaternion`.
         * @returns A new instance of `Quaternion` representing the subtraction of the specified `Quaternion`s.
         */
        public static Subtract(left: ManagedMath.Quaternion, right: ManagedMath.Quaternion): ManagedMath.Quaternion;

        /**
         * Subtracts the specified `Quaternion` from the `Quaternion`.
         *
         * @param right - The second `Quaternion`.
         * @returns A new instance of `Quaternion` representing the subtraction of the specified `Quaternion`s.
         */
        public Subtract(right: ManagedMath.Quaternion): ManagedMath.Quaternion;

        /**
         * Multiplies two `Quaternion`s together.
         *
         * @param left - The first `Quaternion`.
         * @param right - The second `Quaternion`.
         * @returns A new instance of `Quaternion` representing the multiplication of the specified `Quaternion`s.
         */
        public static Multiply(left: ManagedMath.Quaternion, right: ManagedMath.Quaternion): ManagedMath.Quaternion;

        /**
         * Multiplies the `Quaternion` by the specified `Quaternion`.
         *
         * @param right - The second `Quaternion`.
         * @returns A new instance of `Quaternion` representing the multiplication of the specified `Quaternion`s.
         */
        public Multiply(right: ManagedMath.Quaternion): ManagedMath.Quaternion;

        /**
         * Multiplies a `Quaternion` by a specified scalar.
         *
         * @param left - The `Quaternion` to multiply.
         * @param right - The scalar to multiply by.
         * @returns A new instance of `Quaternion` representing the multiplication of the specified `Quaternion` and the specified scalar.
         */
        public static Multiply(left: ManagedMath.Quaternion, right: number): ManagedMath.Quaternion;

        /**
         * Multiplies a `Quaternion` by a specified scalar.
         *
         * @param left - The scalar to multiply by.
         * @param right - The `Quaternion` to multiply.
         * @returns A new instance of `Quaternion` representing the multiplication of the specified `Quaternion` and the specified scalar.
         */
        public static Multiply(left: number, right: ManagedMath.Quaternion): ManagedMath.Quaternion;

        /**
         * Multiplies the `Quaternion` by a specified scalar.
         *
         * @param value - The scalar to multiply by.
         * @returns A new instance of `Quaternion` representing the multiplication of the `Quaternion` and the specified scalar.
         */
        public Multiply(value: number): ManagedMath.Quaternion;
    }

    /**
     * Represents a SIMD enhanced Vector with 2 dimensions.
     */
    class Vector2 extends ManagedObject {
        /**
         * The X component of the `Vector2`.
         *
         * @remarks This property is Read/Write.
         */
        public X: number;

        /**
         * The Y component of the `Vector2`.
         *
         * @remarks This property is Read/Write.
         */
        public Y: number;

        /**
         * Returns a new instance of `Vector2` representing a vector whose `X` and `Y` components are Zero.
         *
         * @remarks This property is Read-Only.
         */
        public static Zero: ManagedMath.Vector2;

        /**
         * Returns a new instance of `Vector2` representing a vector whose `X` and `Y` components are One.
         *
         * @remarks This property is Read-Only.
         */
        public static One: ManagedMath.Vector2;

        /**
         * Returns a new instance of `Vector2` representing a vector whose `X` component is One and all other components are Zero.
         *
         * @remarks This property is Read-Only.
         */
        public static UnitX: ManagedMath.Vector2;

        /**
         * Returns a new instance of `Vector2` representing a vector whose `Y` component is One and all other components are Zero.
         *
         * @remarks This property is Read-Only.
         */
        public static UnitY: ManagedMath.Vector2;

        /**
         * The Managed Type of the object.
         *
         * @remarks This property is Read-Only.
         */
        public Type: ManagedObjectType;

        /**
         * Constructor.
         *
         * @param value - The value of all the components of the `Vector2`.
         */
        constructor(value: number);

        /**
         * Constructor.
         *
         * @param x - The value of the `X` component of the `Vector2`.
         * @param y - The value of the `Y` component of the `Vector2`.
         */
        constructor(x: number, y: number);

        /**
         * Returns the length of the `Vector2`.
         *
         * @returns The length of the `Vector2`.
         */
        public Length(): number;

        /**
         * Returns the length of the `Vector2` squared.
         *
         * @returns The length of the `Vector2` squared.
         */
        public LengthSquared(): number;

        /**
         * Computes the Euclidean distance between the two given `Vector2`.
         *
         * @param value1 - The first `Vector2`.
         * @param value2 - The second `Vector2`.
         * @returns The Euclidean distance between the two given `Vector2`.
         */
        public static Distance(value1: ManagedMath.Vector2, value2: ManagedMath.Vector2): number;

        /**
         * Computes the Euclidean distance between the `Vector2` and the specified `Vector2`.
         *
         * @param value2 - The second `Vector2`.
         * @returns The Euclidean distance between the specified `Vector2`s.
         */
        public Distance(value2: ManagedMath.Vector2): number;

        /**
         * Computes the Euclidean distance squared between the two given `Vector2`.
         *
         * @param value1 - The first `Vector2`.
         * @param value2 - The second `Vector2`.
         * @returns The Euclidean distance squared between the two given `Vector2`.
         */
        public static DistanceSquared(value1: ManagedMath.Vector2, value2: ManagedMath.Vector2): number;

        /**
         * Computes the Euclidean distance squared between the `Vector2` and the specified `Vector2`.
         *
         * @param value2 - The second `Vector2`.
         * @returns The Euclidean distance squared between the specified `Vector2`s.
         */
        public DistanceSquared(value2: ManagedMath.Vector2): number;

        /**
         * Returns a `Vector2` with the same direction as the specified `Vector2`, but with a length of One.
         *
         * @param value - The `Vector2` to normalize.
         * @returns A new instance of `Vector2` representing the result of normalizing the specified `Vector2`.
         */
        public static Normalize(value: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Returns a `Vector2` with the same direction as the `Vector2`, but with a length of One.
         *
         * @returns A new instance of `Vector2` representing the result of normalizing the `Vector2`.
         */
        public Normalize(): ManagedMath.Vector2;

        /**
         * Restricts a `Vector2` between a minimum and a maximum value.
         *
         * @param value1 - The `Vector2` to clamp.
         * @param min - The `Vector2` representing the minimum value to clamp with.
         * @param max - The `Vector2` representing the maximum value to clamp with.
         * @returns A new instance of `Vector2` representing the result of clamping the specified `Vector2` between the specified values.
         */
        public static Clamp(value1: ManagedMath.Vector2, min: ManagedMath.Vector2, max: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Restricts the `Vector2` between a minimum and a maximum value.
         *
         * @param min - The `Vector2` representing the minimum value to clamp with.
         * @param max - The `Vector2` representing the maximum value to clamp with.
         * @returns A new instance of `Vector2` representing the result of clamping the `Vector2` between the specified values.
         */
        public Clamp(min: ManagedMath.Vector2, max: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Performs a linear interpolation between two `Vector2`s based on the given weighting.
         *
         * @param value1 - The first `Vector2`.
         * @param value2 - The second `Vector2`.
         * @param amount - The amount to interpolate by.
         * @returns A new instance of `Vector2` representing the result of interpolating the specified `Vector2`s by the specified `amount`.
         */
        public static Lerp(value1: ManagedMath.Vector2, value2: ManagedMath.Vector2, amount: number): ManagedMath.Vector2;

        /**
         * Adds two `Vector2`s together.
         *
         * @param left - The first `Vector2`.
         * @param right - The second `Vector2`.
         * @returns A new instance of `Vector2` representing the sum of the specified `Vector2`s.
         */
        public static Add(left: ManagedMath.Vector2, right: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Adds the specified `Vector2` to the `Vector2`.
         *
         * @param right - The second `Vector2`.
         * @returns A new instance of `Vector2` representing the sum of the specified `Vector2`s.
         */
        public Add(right: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Subtracts the second `Vector2` from the first.
         *
         * @param left - The first `Vector2`.
         * @param right - The second `Vector2`.
         * @returns A new instance of `Vector2` representing the subtraction of the specified `Vector2`s.
         */
        public static Subtract(left: ManagedMath.Vector2, right: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Subtracts the specified `Vector2` from the `Vector2`.
         *
         * @param right - The second `Vector2`.
         * @returns A new instance of `Vector2` representing the subtraction of the specified `Vector2`s.
         */
        public Subtract(right: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Multiplies two `Vector2`s together.
         *
         * @param left - The first `Vector2`.
         * @param right - The second `Vector2`.
         * @returns A new instance of `Vector2` representing the multiplication of the specified `Vector2`s.
         */
        public static Multiply(left: ManagedMath.Vector2, right: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Multiplies the `Vector2` by the specified `Vector2`.
         *
         * @param right - The second `Vector2`.
         * @returns A new instance of `Vector2` representing the multiplication of the specified `Vector2`s.
         */
        public Multiply(right: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Multiplies a `Vector2` by a specified scalar.
         *
         * @param left - The `Vector2` to multiply.
         * @param right - The scalar to multiply by.
         * @returns A new instance of `Vector2` representing the multiplication of the specified `Vector2` and the specified scalar.
         */
        public static Multiply(left: ManagedMath.Vector2, right: number): ManagedMath.Vector2;

        /**
         * Multiplies a `Vector2` by a specified scalar.
         *
         * @param left - The scalar to multiply by.
         * @param right - The `Vector2` to multiply.
         * @returns A new instance of `Vector2` representing the multiplication of the specified `Vector2` and the specified scalar.
         */
        public static Multiply(left: number, right: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Multiplies the `Vector2` by a specified scalar.
         *
         * @param right - The scalar to multiply by.
         * @returns A new instance of `Vector2` representing the multiplication of the `Vector2` and the specified scalar.
         */
        public Multiply(right: number): ManagedMath.Vector2;

        /**
         * Divides the first `Vector2` by the second.
         *
         * @param left - The first `Vector2`.
         * @param right - The second `Vector2`.
         * @returns A new instance of `Vector2` representing the division of the specified `Vector2`s.
         */
        public static Divide(left: ManagedMath.Vector2, right: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Divides the `Vector2` by the specified `Vector2`.
         *
         * @param right - The second `Vector2`.
         * @returns A new instance of `Vector2` representing the division of the specified `Vector2`s.
         */
        public Divide(right: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Divides the specified `Vector2` by a specified scalar.
         *
         * @param left - The `Vector2` to divide.
         * @param divisor - The scalar to divide by.
         * @returns A new instance of `Vector2` representing the division of the specified `Vector2` and the specified scalar.
         */
        public static Divide(left: ManagedMath.Vector2, divisor: number): ManagedMath.Vector2;

        /**
         * Divides the `Vector2` by a specified scalar.
         *
         * @param divisor - The scalar to divide by.
         * @returns A new instance of `Vector2` representing the division of the `Vector2` and the specified scalar.
         */
        public Divide(divisor: number): ManagedMath.Vector2;

        /**
         * Negates the specified `Vector2`.
         *
         * @param value - The `Vector2` to negate.
         * @returns A new instance of `Vector2` representing the negation of the specified `Vector2`.
         */
        public static Negate(value: ManagedMath.Vector2): ManagedMath.Vector2;

        /**
         * Negates the `Vector2`.
         *
         * @returns A new instance of `Vector2` representing the negation of the `Vector2`.
         */
        public Negate(): ManagedMath.Vector2;

        /**
         * Returns the dot product of two `Vector2`s.
         *
         * @param vector1 - The first `Vector2`.
         * @param vector2 - The second `Vector2`.
         * @returns A new instance of `Vector2` representing the dot product of the specified `Vector2`s.
         */
        public static Dot(vector1: ManagedMath.Vector2, vector2: ManagedMath.Vector2): number;

        /**
         * Returns the dot product of the `Vector2` and the specified `Vector2`.
         *
         * @param vector2 - The second `Vector2`.
         * @returns A new instance of `Vector2` representing the dot product of the specified `Vector2`s.
         */
        public Dot(vector2: ManagedMath.Vector2): number;
    }

    /**
     * Represents a SIMD enhanced Vector with 3 dimensions.
     */
    class Vector3 extends ManagedObject {
        /**
         * The `X` component of the `Vector3`.
         *
         * @remarks This property is Read/Write.
         */
        public X: number;

        /**
         * The `Y` component of the `Vector3`.
         *
         * @remarks This property is Read/Write.
         */
        public Y: number;

        /**
         * The `Z` component of the `Vector3`.
         *
         * @remarks This property is Read/Write.
         */
        public Z: number;

        /**
         * Returns a new instance of `Vector3` representing a vector whose `X`, `Y` and `Z` components are Zero.
         *
         * @remarks This property is Read-Only.
         */
        public static Zero: ManagedMath.Vector3;

        /**
         * Returns a new instance of `Vector3` representing a vector whose `X`, `Y` and `Z` components are One.
         *
         * @remarks This property is Read-Only.
         */
        public static One: ManagedMath.Vector3;

        /**
         * Returns a new instance of `Vector3` representing a vector whose `X` component is One and all other components are Zero.
         *
         * @remarks This property is Read-Only.
         */
        public static UnitX: ManagedMath.Vector3;

        /**
         * Returns a new instance of `Vector3` representing a vector whose `Y` component is One and all other components are Zero.
         *
         * @remarks This property is Read-Only.
         */
        public static UnitY: ManagedMath.Vector3;

        /**
         * Returns a new instance of `Vector3` representing a vector whose `Z` component is One and all other components are Zero.
         *
         * @remarks This property is Read-Only.
         */
        public static UnitZ: ManagedMath.Vector3;

        /**
         * The Managed Type of the object.
         *
         * @remarks This property is Read-Only.
         */
        public Type: ManagedObjectType;

        /**
         * Constructor.
         *
         * @param value - The value of all the components of the `Vector3`.
         */
        constructor(value: number);

        /**
         * Constructor.
         *
         * @param value - The `Vector2` whose `X` and `Y` components will be used for the `Vector3`.
         * @param z - The value of the `Z` component of the `Vector3`.
         */
        constructor(value: ManagedMath.Vector2, z: number);

        /**
         * Constructor.
         *
         * @param x - The value of the `X` component of the `Vector3`.
         * @param y - The value of the `Y` component of the `Vector3`.
         * @param z - The value of the `Z` component of the `Vector3`.
         */
        constructor(x: number, y: number, z: number);

        /**
         * Returns the length of the `Vector3`.
         *
         * @returns The length of the `Vector3`.
         */
        public Length(): number;

        /**
         * Returns the length of the `Vector3` squared.
         *
         * @returns The length of the `Vector3` squared.
         */
        public LengthSquared(): number;

        /**
         * Computes the Euclidean distance between the two given `Vector3`.
         *
         * @param value1 - The first `Vector3`.
         * @param value2 - The second `Vector3`.
         * @returns The Euclidean distance between the two given `Vector3`.
         */
        public static Distance(value1: ManagedMath.Vector3, value2: ManagedMath.Vector3): number;

        /**
         * Computes the Euclidean distance between the `Vector3` and the specified `Vector3`.
         *
         * @param value - The second `Vector3`.
         * @returns The Euclidean distance between the specified `Vector3`s.
         */
        public Distance(value: ManagedMath.Vector3): number;

        /**
         * Computes the Euclidean distance squared between the two given `Vector3`.
         *
         * @param value1 - The first `Vector3`.
         * @param value2 - The second `Vector3`.
         * @returns The Euclidean distance squared between the two given `Vector3`.
         */
        public static DistanceSquared(value1: ManagedMath.Vector3, value2: ManagedMath.Vector3): number;

        /**
         * Computes the Euclidean distance squared between the `Vector3` and the specified `Vector3`.
         *
         * @param value - The second `Vector3`.
         * @returns The Euclidean distance squared between the specified `Vector3`s.
         */
        public DistanceSquared(value: ManagedMath.Vector3): number;

        /**
         * Returns a `Vector3` with the same direction as the specified `Vector3`, but with a length of One.
         *
         * @param value - The `Vector3` to normalize.
         * @returns A new instance of `Vector3` representing the result of normalizing the specified `Vector3`.
         */
        public static Normalize(value: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Returns a `Vector3` with the same direction as the `Vector3`, but with a length of One.
         *
         * @returns A new instance of `Vector3` representing the result of normalizing the `Vector3`.
         */
        public Normalize(): ManagedMath.Vector3;

        /**
         * Returns the cross product of two `Vector3`s.
         *
         * @param vector1 - The first `Vector3`.
         * @param vector2 - The second `Vector3`.
         * @returns A new instance of `Vector3` representing the cross product of the specified `Vector3`s.
         */
        public static Cross(vector1: ManagedMath.Vector3, vector2: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Returns the cross product of the `Vector3` and the specified `Vector3`.
         *
         * @param vector - The second `Vector3`.
         * @returns A new instance of `Vector3` representing the cross product of the specified `Vector3`s.
         */
        public Cross(vector: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Restricts a `Vector3` between a minimum and a maximum value.
         *
         * @param value1 - The `Vector3` to clamp.
         * @param min - The `Vector3` representing the minimum value to clamp with.
         * @param max - The `Vector3` representing the maximum value to clamp with.
         * @returns A new instance of `Vector3` representing the result of clamping the specified `Vector3` between the specified values.
         */
        public static Clamp(value1: ManagedMath.Vector3, min: ManagedMath.Vector3, max: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Restricts the `Vector3` between a minimum and a maximum value.
         *
         * @param min - The `Vector3` representing the minimum value to clamp with.
         * @param max - The `Vector3` representing the maximum value to clamp with.
         * @returns A new instance of `Vector3` representing the result of clamping the `Vector3` between the specified values.
         */
        public Clamp(min: ManagedMath.Vector3, max: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Performs a linear interpolation between two `Vector3`s based on the given weighting.
         *
         * @param value1 - The first `Vector3`.
         * @param value2 - The second `Vector3`.
         * @param amount - The amount to interpolate by.
         * @returns A new instance of `Vector3` representing the result of interpolating the specified `Vector3`s by the specified `amount`.
         */
        public static Lerp(value1: ManagedMath.Vector3, value2: ManagedMath.Vector3, amount: number): ManagedMath.Vector3;

        /**
         * Adds two `Vector3`s together.
         *
         * @param left - The first `Vector3`.
         * @param right - The second `Vector3`.
         * @returns A new instance of `Vector3` representing the sum of the specified `Vector3`s.
         */
        public static Add(left: ManagedMath.Vector3, right: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Adds the specified `Vector3` to the `Vector3`.
         *
         * @param right - The second `Vector3`.
         * @returns A new instance of `Vector3` representing the sum of the specified `Vector3`s.
         */
        public Add(right: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Subtracts the second `Vector3` from the first.
         *
         * @param left - The first `Vector3`.
         * @param right - The second `Vector3`.
         * @returns A new instance of `Vector3` representing the subtraction of the specified `Vector3`s.
         */
        public static Subtract(left: ManagedMath.Vector3, right: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Subtracts the specified `Vector3` from the `Vector3`.
         *
         * @param right - The second `Vector3`.
         * @returns A new instance of `Vector3` representing the subtraction of the specified `Vector3`s.
         */
        public Subtract(right: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Multiplies two `Vector3`s together.
         *
         * @param left - The first `Vector3`.
         * @param right - The second `Vector3`.
         * @returns A new instance of `Vector3` representing the multiplication of the specified `Vector3`s.
         */
        public static Multiply(left: ManagedMath.Vector3, right: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Multiplies the `Vector3` by the specified `Vector3`.
         *
         * @param right - The second `Vector3`.
         * @returns A new instance of `Vector3` representing the multiplication of the specified `Vector3`s.
         */
        public Multiply(right: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Multiplies a `Vector3` by a specified scalar.
         *
         * @param left - The `Vector3` to multiply.
         * @param right - The scalar to multiply by.
         * @returns A new instance of `Vector3` representing the multiplication of the specified `Vector3` and the specified scalar.
         */
        public static Multiply(left: ManagedMath.Vector3, right: number): ManagedMath.Vector3;

        /**
         * Multiplies a `Vector3` by a specified scalar.
         *
         * @param left - The scalar to multiply by.
         * @param right - The `Vector3` to multiply.
         * @returns A new instance of `Vector3` representing the multiplication of the specified `Vector3` and the specified scalar.
         */
        public static Multiply(left: number, right: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Multiplies the `Vector3` by a specified scalar.
         *
         * @param value - The scalar to multiply by.
         * @returns A new instance of `Vector3` representing the multiplication of the `Vector3` and the specified scalar.
         */
        public Multiply(value: number): ManagedMath.Vector3;

        /**
         * Divides the first `Vector3` by the second.
         *
         * @param left - The first `Vector3`.
         * @param right - The second `Vector3`.
         * @returns A new instance of `Vector3` representing the division of the specified `Vector3`s.
         */
        public static Divide(left: ManagedMath.Vector3, right: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Divides the `Vector3` by the specified `Vector3`.
         *
         * @param right - The second `Vector3`.
         * @returns A new instance of `Vector3` representing the division of the specified `Vector3`s.
         */
        public Divide(right: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Divides the specified `Vector3` by a specified scalar.
         *
         * @param left - The `Vector3` to divide.
         * @param divisor - The scalar to divide by.
         * @returns A new instance of `Vector3` representing the division of the specified `Vector3` and the specified scalar.
         */
        public static Divide(left: ManagedMath.Vector3, divisor: number): ManagedMath.Vector3;

        /**
         * Divides the `Vector3` by a specified scalar.
         *
         * @param divisor - The scalar to divide by.
         * @returns A new instance of `Vector3` representing the division of the `Vector3` and the specified scalar.
         */
        public Divide(divisor: number): ManagedMath.Vector3;

        /**
         * Negates the specified `Vector3`.
         *
         * @param value - The `Vector3` to negate.
         * @returns A new instance of `Vector3` representing the negation of the specified `Vector3`.
         */
        public static Negate(value: ManagedMath.Vector3): ManagedMath.Vector3;

        /**
         * Negates the `Vector3`.
         *
         * @returns A new instance of `Vector3` representing the negation of the `Vector3`.
         */
        public Negate(): ManagedMath.Vector3;

        /**
         * Returns the dot product of two `Vector3`s.
         *
         * @param vector1 - The first `Vector3`.
         * @param vector2 - The second `Vector3`.
         * @returns A new instance of `Vector3` representing the dot product of the specified `Vector3`s.
         */
        public static Dot(vector1: ManagedMath.Vector3, vector2: ManagedMath.Vector3): number;

        /**
         * Returns the dot product of the `Vector3` and the specified `Vector3`.
         *
         * @param vector2 - The second `Vector3`.
         * @returns A new instance of `Vector3` representing the dot product of the specified `Vector3`s.
         */
        public Dot(vector2: ManagedMath.Vector3): number;
    }

    /**
     * Represents a SIMD enhanced Vector with 4 dimensions.
     */
    class Vector4 extends ManagedObject {
        /**
         * The `X` component of the `Vector4`.
         *
         * @remarks This property is Read/Write.
         */
        public X: number;

        /**
         * The `Y` component of the `Vector4`.
         *
         * @remarks This property is Read/Write.
         */
        public Y: number;

        /**
         * The `Z` component of the `Vector4`.
         *
         * @remarks This property is Read/Write.
         */
        public Z: number;

        /**
         * The `W` component of the `Vector4`.
         *
         * @remarks This property is Read/Write.
         */
        public W: number;

        /**
         * Returns a new instance of `Vector4` representing a vector whose `X`, `Y`, `Z` and `W` components are Zero.
         *
         * @remarks This property is Read-Only.
         */
        public static Zero: ManagedMath.Vector4;

        /**
         * Returns a new instance of `Vector4` representing a vector whose `X`, `Y`, `Z` and `W` components are One.
         *
         * @remarks This property is Read-Only.
         */
        public static One: ManagedMath.Vector4;

        /**
         * Returns a new instance of `Vector4` representing a vector whose `X` component is One and all other components are Zero.
         *
         * @remarks This property is Read-Only.
         */
        public static UnitX: ManagedMath.Vector4;

        /**
         * Returns a new instance of `Vector4` representing a vector whose `Y` component is One and all other components are Zero.
         *
         * @remarks This property is Read-Only.
         */
        public static UnitY: ManagedMath.Vector4;

        /**
         * Returns a new instance of `Vector4` representing a vector whose `Z` component is One and all other components are Zero.
         *
         * @remarks This property is Read-Only.
         */
        public static UnitZ: ManagedMath.Vector4;

        /**
         * Returns a new instance of `Vector4` representing a vector whose `W` component is One and all other components are Zero.
         *
         * @remarks This property is Read-Only.
         */
        public static UnitW: ManagedMath.Vector4;

        /**
         * The Managed Type of the object.
         *
         * @remarks This property is Read-Only.
         */
        public Type: ManagedObjectType;

        /**
         * Constructor.
         *
         * @param value - The value of all the components of the `Vector4`.
         */
        constructor(value: number);

        /**
         * Constructor.
         *
         * @param value - The `Vector2` whose `X` and `Y` components will be used for the `Vector4`.
         * @param z - The value of the `Z` component of the `Vector4`.
         * @param w - The value of the `W` component of the `Vector4`.
         */
        constructor(value: ManagedMath.Vector2, z: number, w: number);

        /**
         * Constructor.
         *
         * @param x - The value of the `X` component of the `Vector4`.
         * @param y - The value of the `Y` component of the `Vector4`.
         * @param z - The value of the `Z` component of the `Vector4`.
         * @param w - The value of the `W` component of the `Vector4`.
         */
        constructor(x: number, y: number, z: number, w: number);

        /**
         * Constructor.
         *
         * @param value - The `Vector3` whose `X`, `Y` and `Z` components will be used for the `Vector4`.
         * @param w - The value of the `W` component of the `Vector4`.
         */
        constructor(value: ManagedMath.Vector3, w: number);

        /**
         * Returns the length of the `Vector4`.
         *
         * @returns The length of the `Vector4`.
         */
        public Length(): number;

        /**
         * Returns the length of the `Vector4` squared.
         *
         * @returns The length of the `Vector4` squared.
         */
        public LengthSquared(): number;

        /**
         * Computes the Euclidean distance between the two given `Vector4`.
         *
         * @param value1 - The first `Vector4`.
         * @param value2 - The second `Vector4`.
         * @returns The Euclidean distance between the two given `Vector4`.
         */
        public static Distance(value1: ManagedMath.Vector4, value2: ManagedMath.Vector4): number;

        /**
         * Computes the Euclidean distance between the `Vector4` and the specified `Vector4`.
         *
         * @param value2 - The second `Vector4`.
         * @returns The Euclidean distance between the specified `Vector4`s.
         */
        public Distance(value2: ManagedMath.Vector4): number;

        /**
         * Computes the Euclidean distance squared between the two given `Vector4`.
         *
         * @param value1 - The first `Vector4`.
         * @param value2 - The second `Vector4`.
         * @returns The Euclidean distance squared between the two given `Vector4`.
         */
        public static DistanceSquared(value1: ManagedMath.Vector4, value2: ManagedMath.Vector4): number;

        /**
         * Computes the Euclidean distance squared between the `Vector4` and the specified `Vector4`.
         *
         * @param value2 - The second `Vector4`.
         * @returns The Euclidean distance squared between the specified `Vector4`s.
         */
        public DistanceSquared(value2: ManagedMath.Vector4): number;

        /**
         * Returns a `Vector4` with the same direction as the specified `Vector4`, but with a length of One.
         *
         * @param value - The `Vector4` to normalize.
         * @returns A new instance of `Vector4` representing the result of normalizing the specified `Vector4`.
         */
        public static Normalize(value: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Returns a `Vector4` with the same direction as the `Vector4`, but with a length of One.
         *
         * @returns A new instance of `Vector4` representing the result of normalizing the `Vector4`.
         */
        public Normalize(): ManagedMath.Vector4;

        /**
         * Restricts a `Vector4` between a minimum and a maximum value.
         *
         * @param value1 - The `Vector4` to clamp.
         * @param min - The `Vector4` representing the minimum value to clamp with.
         * @param max - The `Vector4` representing the maximum value to clamp with.
         * @returns A new instance of `Vector4` representing the result of clamping the specified `Vector4` between the specified values.
         */
        public static Clamp(value1: ManagedMath.Vector4, min: ManagedMath.Vector4, max: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Restricts the `Vector4` between a minimum and a maximum value.
         *
         * @param min - The `Vector4` representing the minimum value to clamp with.
         * @param max - The `Vector4` representing the maximum value to clamp with.
         * @returns A new instance of `Vector4` representing the result of clamping the `Vector4` between the specified values.
         */
        public Clamp(min: ManagedMath.Vector4, max: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Performs a linear interpolation between two `Vector4`s based on the given weighting.
         *
         * @param value1 - The first `Vector4`.
         * @param value2 - The second `Vector4`.
         * @param amount - The amount to interpolate by.
         * @returns A new instance of `Vector4` representing the result of interpolating the specified `Vector4`s by the specified `amount`.
         */
        public static Lerp(value1: ManagedMath.Vector4, value2: ManagedMath.Vector4, amount: number): ManagedMath.Vector4;

        /**
         * Adds two `Vector4`s together.
         *
         * @param left - The first `Vector4`.
         * @param right - The second `Vector4`.
         * @returns A new instance of `Vector4` representing the sum of the specified `Vector4`s.
         */
        public static Add(left: ManagedMath.Vector4, right: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Adds the specified `Vector4` to the `Vector4`.
         *
         * @param right - The second `Vector4`.
         * @returns A new instance of `Vector4` representing the sum of the specified `Vector4`s.
         */
        public Add(right: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Subtracts the second `Vector4` from the first.
         *
         * @param left - The first `Vector4`.
         * @param right - The second `Vector4`.
         * @returns A new instance of `Vector4` representing the subtraction of the specified `Vector4`s.
         */
        public static Subtract(left: ManagedMath.Vector4, right: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Subtracts the specified `Vector4` from the `Vector4`.
         *
         * @param right - The second `Vector4`.
         * @returns A new instance of `Vector4` representing the subtraction of the specified `Vector4`s.
         */
        public Subtract(right: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Multiplies two `Vector4`s together.
         *
         * @param left - The first `Vector4`.
         * @param right - The second `Vector4`.
         * @returns A new instance of `Vector4` representing the multiplication of the specified `Vector4`s.
         */
        public static Multiply(left: ManagedMath.Vector4, right: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Multiplies the `Vector4` by the specified `Vector4`.
         *
         * @param right - The second `Vector4`.
         * @returns A new instance of `Vector4` representing the multiplication of the specified `Vector4`s.
         */
        public Multiply(right: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Multiplies a `Vector4` by a specified scalar.
         *
         * @param left - The `Vector4` to multiply.
         * @param right - The scalar to multiply by.
         * @returns A new instance of `Vector4` representing the multiplication of the specified `Vector4` and the specified scalar.
         */
        public static Multiply(left: ManagedMath.Vector4, right: number): ManagedMath.Vector4;

        /**
         * Multiplies a `Vector4` by a specified scalar.
         *
         * @param left - The scalar to multiply by.
         * @param right - The `Vector4` to multiply.
         * @returns A new instance of `Vector4` representing the multiplication of the specified `Vector4` and the specified scalar.
         */
        public static Multiply(left: number, right: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Multiplies the `Vector4` by a specified scalar.
         *
         * @param value - The scalar to multiply by.
         * @returns A new instance of `Vector4` representing the multiplication of the `Vector4` and the specified scalar.
         */
        public Multiply(value: number): ManagedMath.Vector4;

        /**
         * Divides the first `Vector4` by the second.
         *
         * @param left - The first `Vector4`.
         * @param right - The second `Vector4`.
         * @returns A new instance of `Vector4` representing the division of the specified `Vector4`s.
         */
        public static Divide(left: ManagedMath.Vector4, right: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Divides the `Vector4` by the specified `Vector4`.
         *
         * @param right - The second `Vector4`.
         * @returns A new instance of `Vector4` representing the division of the specified `Vector4`s.
         */
        public Divide(right: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Divides the specified `Vector4` by a specified scalar.
         *
         * @param left - The `Vector4` to divide.
         * @param divisor - The scalar to divide by.
         * @returns A new instance of `Vector4` representing the division of the specified `Vector4` and the specified scalar.
         */
        public static Divide(left: ManagedMath.Vector4, divisor: number): ManagedMath.Vector4;

        /**
         * Divides the `Vector4` by a specified scalar.
         *
         * @param divisor - The scalar to divide by.
         * @returns A new instance of `Vector4` representing the division of the `Vector4` and the specified scalar.
         */
        public Divide(divisor: number): ManagedMath.Vector4;

        /**
         * Negates the specified `Vector4`.
         *
         * @param value - The `Vector4` to negate.
         * @returns A new instance of `Vector4` representing the negation of the specified `Vector4`.
         */
        public static Negate(value: ManagedMath.Vector4): ManagedMath.Vector4;

        /**
         * Negates the `Vector4`.
         *
         * @returns A new instance of `Vector4` representing the negation of the `Vector4`.
         */
        public Negate(): ManagedMath.Vector4;

        /**
         * Returns the dot product of two `Vector4`s.
         *
         * @param vector1 - The first `Vector3`.
         * @param vector2 - The second `Vector3`.
         * @returns A new instance of `Vector4` representing the dot product of the specified `Vector4`s.
         */
        public static Dot(vector1: ManagedMath.Vector4, vector2: ManagedMath.Vector4): number;

        /**
         * Returns the dot product of the `Vector4` and the specified `Vector4`.
         *
         * @param vector2 - The second `Vector4`.
         * @returns A new instance of `Vector4` representing the dot product of the specified `Vector4`s.
         */
        public Dot(vector2: ManagedMath.Vector4): number;
    }
}

/**
 * Contains wrappers for Logging utilities.
 */
declare namespace Logging {
    /**
     * Represents the different severity levels a log message can have.
     */
    enum LogSeverity {
        /**
         * Used for messages the user should never see unless an issue is being reported.
         */
        Debug = 0,

        /**
         * Used for messages that inform about the flow of the engine or game but are not critical.
         */
        Info = 1,

        /**
         * Used for messages that are worth looking into but are not going to cause trouble in most cases.
         */
        Warning = 2,

        /**
         * Used for messages that represent a recoverable error.
         */
        Error = 3,

        /**
         * Used for messages that represent an unrecoverable error. The engine should shutdown after emitting this kind of error.
         */
        CriticalError = 4,
    }

    /**
     * Appends a line to the log.
     *
     * @param severity - The severity of the message
     * @param nameSpace - The namespace of the message. Adding too many namespaces makes the log hard to read, use with care.
     * @param message - The message to log
     */
    function Append(severity: Logging.LogSeverity, nameSpace: string, message: string): void;
}

/**
 * Contains aliases for the Logging namespace.
 */
// @ts-ignore
declare namespace console {
    /**
     * Appends a line to the log with `LogSeverity.Info` severity.
     *
     * @param message - The message to log
     */
    function log(message: string): void;
}

/**
 * Provides functionality to handle sound.
 */
declare namespace SoundController {
    /**
     * Whether the audio system is globally muted.
     *
     * @remarks This property is Read-Only.
     */
    let AudioMuted: boolean;

    /**
     * The current global volume of the audio system.
     *
     * @remarks This property is Read-Only.
     */
    let GlobalVolume: number;

    /**
     * Globally mutes the audio system.
     */
    function MuteAudio(): void;

    /**
     * Globally unmutes the audio system.
     */
    function UnmuteAudio(): void;

    /**
     * Sets the global volume the audio system.
     *
     * @param volume - The value to set the global volume to.
     */
    function SetGlobalVolume(volume: number): void;
}

/**
 * Provides functionality to handle scenes.
 */
declare namespace SceneController {
    /**
     * The currently loaded `Scene`.
     *
     * @remarks This property is Read-Only.
     */
    let ActiveScene: Scene;

    /**
     * The list of the resource ids of all the available scenes.
     *
     * @remarks This property is Read-Only.
     */
    let AvailableScenes: Array<string>;

    /**
     * Unloads the current `Scene` and loads the requested `Scene`.
     *
     * @param id - The id of the resource of the `IScene` to load.
     */
    function ChangeScene(id: string): void;
}

/**
 * Provides functionality to handle input.
 */
declare namespace InputController {
    /**
     * The currently active Action Map.
     *
     * @remarks This property is Read-Only.
     */
    let ActionMap: Array<InputAction>;

    /**
     * Creates a new `InputAction`.
     *
     * @param name - The name of the `InputAction` to create.
     * @returns The newly created `InputAction`.
     */
    function CreateInputAction(name: string): InputAction;

    /**
     * Removes an `InputAction`.
     *
     * @param name - The name of the `InputAction` to remove.
     */
    function RemoveInputAction(name: string): void;
}

/**
 * Represents a managed wrapper.
 */
declare interface IManagedWrapper {
    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    Type: ManagedObjectType;
}

/**
 * Represents an engine component.
 */
declare interface IComponent extends IManagedWrapper, IActivable, INameable, IParentable {
    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    Id: string;
}

/**
 * Represents an activable object.
 */
declare interface IActivable {
    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    ActiveInGraph: boolean;
}

/**
 * Represents an object that can have components attached.
 */
declare interface IComponentable {
    /**
     * A list of all the components attached to the object.
     *
     * @remarks This property is Read-Only.
     */
    Components: Array<IComponent>;

    /**
     * Attaches a component to the object.
     *
     * @param component - The component to attach.
     */
    AttachComponent(component: IComponent): void;

    /**
     * Attaches a list of components to the object.
     *
     * @param components - The list of components to attach.
     */
    AttachComponents(components: Array<IComponent>): void;

    /**
     * Removes a component from the object.
     *
     * @param component - The component to remove.
     */
    RemoveComponent(component: IComponent): void;

    /**
     * Removes a list of components from the object.
     *
     * @param components - The list of components to remove.
     */
    RemoveComponents(components: Array<IComponent>): void;
}

/**
 * Represents a drawable object.
 */
declare interface IDrawable extends IActivable, ITransformable {
    /**
     * Whether the `IDrawable` should be drawn to screen.
     * Setting this property to `false` does NOT unload the `IDrawable` from memory.
     * Using this property is significantly faster than (de)activating the `IDrawable` and should be preferred over (de)activation for animation.
     * Most `IDrawable` will default to `true` unless this property has explicitly been set before activating them.
     *
     * @remarks This property is Read/Write.
     */
    ShouldDraw: boolean;
}

/**
 * Represents a nameable object.
 */
declare interface INameable {
    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    Name: string;
}

/**
 * Represents an object that can be parented to another object.
 */
declare interface IParentable {
    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    Parent: GameObject | Scene;
}

/**
 * Represents a transformable object.
 */
declare interface ITransformable {
    /**
     * The transform of the object.
     *
     * @remarks This property is Read-Only.
     */
    Transform: Transform;

    /**
     * The transform of the object in world space.
     * This property takes into account the transforms of the parents of the object.
     * Changing the values returned by this property has no effect as the world space transform is calculated on demand.
     *
     * @remarks This property is Read-Only.
     */
    WorldSpaceTransform: Transform;
}

/**
 * Represents a wrapper for a Managed event handler.
 */
declare class EventHandler<TDelegate extends Function> implements IManagedWrapper {
    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * Constructor.
     */
    constructor();

    /**
     * Subscribes a function to the event.
     *
     * @param func - The function to subscribe to the `EventHandler`.
     */
    public Subscribe(func: TDelegate): void;

    /**
     * Unsubscribes a function to the event.
     *
     * @param func - The function to unsubscribe to the `EventHandler`.
     */
    public UnSubscribe(func: TDelegate): void;

    /**
     * Clears all functions from the event.
     */
    public Clear(): void;

    /**
     * Fires the event, calling all the subscribed functions with no guartanteed order.
     * Arguments must match the event signature.
     *
     * @param args - The arguments of the `EventHandler`.
     */
    public Fire(...args: any): void;
}

/**
 * Represents a Managed class or struct.
 */
declare abstract class ManagedObject implements IManagedWrapper {
    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * Indicates whether the current object is equal to another object of the same type.
     *
     * @param other - The other object of the same type to check equality against.
     * @returns `true` if both objects are the same, `false` otherwise.
     */
    public Equals(other: ManagedObject): boolean;

    /**
     * Indicates whether the current object is equal to another object of the same type.
     *
     * @param obj - The other object of the same type to check equality against.
     * @returns `true` if both objects are the same, `false` otherwise.
     */
    public Equals(obj: any): boolean;
}

/**
 * Represents the position, rotation and scale in space of a Component.
 */
declare class Transform extends ManagedObject {
    /**
     * The position of the `Transform`.
     *
     * @remarks This property is Read/Write.
     */
    public Position: ManagedMath.Vector3;

    /**
     * The rotation of the `Transform` (in degrees).
     *
     * @remarks This property is Read/Write.
     */
    public Rotation: ManagedMath.Quaternion;

    /**
     * The scale of the `Transform`.
     *
     * @remarks This property is Read/Write.
     */
    public Scale: ManagedMath.Vector3;

    /**
     * The right vector of the `Transform`.
     *
     * @remarks This property is Read-Only.
     */
    public Right: ManagedMath.Vector3;

    /**
     * The up vector of the `Transform`.
     *
     * @remarks This property is Read-Only.
     */
    public Up: ManagedMath.Vector3;

    /**
     * The forward vector of the `Transform`.
     *
     * @remarks This property is Read-Only.
     */
    public Forward: ManagedMath.Vector3;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;
}

/**
 * Represents a Texture.
 */
declare abstract class Texture extends ManagedObject {
    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;
}

/**
 * Represents a TextSprite Component.
 */
declare abstract class TextSprite extends ManagedObject implements IComponent, IDrawable {
    /**
     * The `ShaderProgram` used to render the `TextSprite`.
     *
     * @remarks This property is Read/Write.
     */
    public ShaderProgram: ShaderProgram;

    /**
     * The text the `TextSprite` will render.
     *
     * @remarks This property is Read/Write.
     */
    public Text: string;

    /**
     * The size of the font the `TextSprite` will render.
     * WARNING: This is NOT the same as the scale of the transform of the `TextSprite`, this property is applied before any spatial scaling is applied.
     * It is recommended to scale text using this property instead of adjusting the scale of the transform as this will do a better job at preventing
     * aliasing of the glyphs.
     *
     * @remarks This property is Read/Write.
     */
    public FontSize: number;

    /**
     * The separation the `TextSprite` will keep between characters.
     * A value of 1 means the default character separation of the used font before kerning is applied.
     * The value of this property represents a scaling factor applied to the default value.
     *
     * @remarks This property is Read/Write.
     */
    public CharacterSeparation: number;

    /**
     * The width the `TextSprite` will use to represent white spaces.
     * A value of 1 means the default white space character width of the used font before kerning is applied.
     * The value of this property represents a scaling factor applied to the default value.
     *
     * @remarks This property is Read/Write.
     */
    public WhiteSpaceSeparation: number;

    /**
     * The horizontal alignment of the `TextSprite`.
     *
     * @remarks This property is Read/Write.
     */
    public AlignmentHorizontal: TextAlignmentHorizontal;

    /**
     * The vertical alignment of the `TextSprite`.
     *
     * @remarks This property is Read/Write.
     */
    public AlignmentVertical: TextAlignmentHorizontal;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    public Id: string;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;

    /**
     * Whether the `IDrawable` should be drawn to screen.
     * Setting this property to `false` does NOT unload the `IDrawable` from memory.
     * Using this property is significantly faster than (de)activating the `IDrawable` and should be preferred over (de)activation for animation.
     * Most `IDrawable` will default to `true` unless this property has explicitly been set before activating them.
     *
     * @remarks This property is Read/Write.
     */
    public ShouldDraw: boolean;

    /**
     * The transform of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Transform: Transform;

    /**
     * The transform of the object in world space.
     * This property takes into account the transforms of the parents of the object.
     * Changing the values returned by this property has no effect as the world space transform is calculated on demand.
     *
     * @remarks This property is Read-Only.
     */
    public WorldSpaceTransform: Transform;
}

/**
 * Represents a Sound Component.
 */
declare abstract class Sound extends ManagedObject implements IComponent, ITransformable {
    /**
     * The transform of the `Sound`.
     *
     * @remarks This property is Read-Only.
     */
    public Transform: Transform;

    /**
     * Defines whether the `Sound` will automatically play when it is activated.
     * The behaviour of this property depends on the sound engine being used.
     *
     * @remarks This property is Read/Write.
     */
    public AutoPlayOnActive: boolean;

    /**
     * The playback status of the `Sound`.
     * The behaviour of this property depends on the sound engine being used.
     *
     * @remarks This property is Read-Only.
     */
    public PlaybackStatus: SoundPlaybackStatus;

    /**
     * The `SoundBank` the `Sound` belongs to.
     *
     * @remarks This property is Read-Only.
     */
    public SoundBank: SoundBank;

    /**
     * The volume of the `Sound`.
     * The behaviour of this property depends on the sound engine being used.
     *
     * @remarks This property is Read/Write.
     */
    public Volume: number;

    /**
     * The pitch of the `Sound`.
     * The behaviour of this property depends on the sound engine being used.
     *
     * @remarks This property is Read/Write.
     */
    public Pitch: number;

    /**
     * The position on the timeline of the `Sound`.
     * The behaviour of this property depends on the sound engine being used.
     *
     * @remarks This property is Read/Write.
     */
    public TimelinePosition: number;

    /**
     * An `EventHandler` that fires when the `Sound` stops playing.
     *
     * @remarks This property is Read-Only.
     */
    public OnSoundStop: EventHandler<(sound: Sound) => void>;

    /**
     * An `EventHandler` that fires when the `Sound` becomes audible due to 3D positional audio constraints.
     *
     * @remarks This property is Read-Only.
     */
    public OnBecameAudible: EventHandler<(sound: Sound) => void>;

    /**
     * An `EventHandler` that fires when the `Sound` becomes not audible due to 3D positional audio constraints.
     *
     * @remarks This property is Read-Only.
     */
    public OnBecameNotAudible: EventHandler<(sound: Sound) => void>;

    /**
     * An `EventHandler` that fires when the `Sound` reaches a named marker on the timeline.
     *
     * @remarks This property is Read-Only.
     */
    public OnTimelineMarkerReached: EventHandler<(sound: Sound, name: string, position: number) => void>;

    /**
     * An `EventHandler` that fires for each beat when the `Sound` reaches beat area on the timeline.
     *
     * @remarks This property is Read-Only.
     */
    public OnTimelineBeat: EventHandler<(sound: Sound, bar: number, beat: number, position: number, tempo: number) => void>;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    public Id: string;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;

    /**
     * The transform of the object in world space.
     * This property takes into account the transforms of the parents of the object.
     * Changing the values returned by this property has no effect as the world space transform is calculated on demand.
     *
     * @remarks This property is Read-Only.
     */
    public WorldSpaceTransform: Transform;

    /**
     * Starts playing the `Sound`.
     */
    public Play(): void;

    /**
     * Pauses the `Sound`.
     */
    public Pause(): void;

    /**
     * Unpauses the `Sound`.
     */
    public UnPause(): void;

    /**
     * Stops playing the `Sound`.
     *
     * @param fadeOut - Whether to fade out the sound. `true` to allow for fade out to occur, `false` to stop playing immediately.
     */
    public Stop(fadeOut: boolean): void;

    /**
     * Gets a named property of the `Sound`.
     *
     * @param name - The name of the property to retrieve.
     * @returns The value of the specified property.
     * The behaviour of this function depends on the sound engine being used.
     */
    public GetParameter(name: string): number;

    /**
     * Sets the value of a named property of the `Sound`.
     * The behaviour of this function depends on the sound engine being used.
     *
     * @param name - The name of the property to set the value of.
     * @param value - The value to set the property to.
     */
    public SetParameter(name: string, value: number): void;

    /**
     * Triggers the next cue found on the timeline of the `Sound`.
     * The behaviour of this function depends on the sound engine being used.
     */
    public TriggerCue(): void;
}

/**
 * Represents a Sound Bank Component.
 */
declare abstract class SoundBank extends ManagedObject implements IComponent {
    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    public Id: string;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;
}

/**
 * Represents a Shader Component.
 */
declare abstract class Shader extends ManagedObject implements IComponent {
    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    public Id: string;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;
}

/**
 * Represents a Shader Program Component.
 */
declare abstract class ShaderProgram extends ManagedObject implements IComponent {
    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    public Id: string;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;
}

/**
 * Represents a Script Component.
 */
declare abstract class Script extends ManagedObject implements IComponent {
    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    public Id: string;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;

    /**
     * Gets a scripting environment property of the script.
     *
     * @param propertyName - The name of the property to retrieve the value of.
     * @returns The value of the specified property or the `undefined` equivalent of the current scripting environment if the property doesn't exist.
     */
    public GetProperty(propertyName: string): any;

    /**
     * Sets a scripting environment property of the script.
     * The property must exist at the time of the invocation of this method and its value must not bethe `undefined` equivalent of the current scripting environment.
     *
     * @param propertyName - The name of the property to set the value of.
     * @param value - The value to set the property to.
     */
    public SetProperty(propertyName: string, value: any): void;
}

/**
 * Represents a Scene.
 */
declare class Scene extends ManagedObject implements IActivable, INameable, IComponentable {
    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * A list of all the components attached to the object.
     *
     * @remarks This property is Read-Only.
     */
    public Components: Array<IComponent>;

    /**
     * Attaches a component to the object.
     *
     * @param component - The component to attach.
     */
    public AttachComponent(component: IComponent): void;

    /**
     * Attaches a list of components to the object.
     *
     * @param components - The list of components to attach.
     */
    public AttachComponents(components: Array<IComponent>): void;

    /**
     * Removes a component from the object.
     *
     * @param component - The component to remove.
     */
    public RemoveComponent(component: IComponent): void;

    /**
     * Removes a list of components from the object.
     *
     * @param components - The list of components to remove.
     */
    public RemoveComponents(components: Array<IComponent>): void;
}

/**
 * Represents the information about a collision.
 */
declare abstract class CollisionData extends ManagedObject {
    /**
     * The `RigidBody` that collided.
     *
     * @remarks This property is Read-Only.
     */
    public SelfBody: RigidBody;

    /**
     * The other `RigidBody` the `RigidBody` collided with.
     *
     * @remarks This property is Read-Only.
     */
    public OtherBody: RigidBody;

    /**
     * The points, in local space, of the collision for the `RigidBody`.
     *
     * @remarks This property is Read-Only.
     */
    public ContactPointsSelf: Array<ManagedMath.Vector3>;

    /**
     * The points, in local space, of the collision for the other `RigidBody`.
     *
     * @remarks This property is Read-Only.
     */
    public ContactPointsOther: Array<ManagedMath.Vector3>;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;
}

/**
 * Represents a RigidBody Component.
 */
declare abstract class RigidBody extends ManagedObject implements IComponent {
    /**
     * The angular damping of the `RigidBody`.
     *
     * @remarks This property is Read/Write.
     */
    public AngularDamping: number;

    /**
     * The angular factor of the `RigidBody`.
     *
     * @remarks This property is Read/Write.
     */
    public AngularFactor: ManagedMath.Vector3;

    /**
     * The angular velocity of the `RigidBody`.
     *
     * @remarks This property is Read/Write.
     */
    public AngularVelocity: ManagedMath.Vector3;

    /**
     * The center of mass of the `RigidBody`.
     *
     * @remarks This property is Read-Only.
     */
    public CenterOfMassPosition: ManagedMath.Vector3;

    /**
     * The gravity force of the `RigidBody`.
     *
     * @remarks This property is Read/Write.
     */
    public Gravity: ManagedMath.Vector3;

    /**
     * The linear damping of the `RigidBody`.
     *
     * @remarks This property is Read/Write.
     */
    public LinearDamping: number;

    /**
     * The linear factor of the `RigidBody`.
     *
     * @remarks This property is Read/Write.
     */
    public LinearFactor: ManagedMath.Vector3;

    /**
     * The linear velocity of the `RigidBody`.
     *
     * @remarks This property is Read/Write.
     */
    public LinearVelocity: ManagedMath.Vector3;

    /**
     * The local inertia of the `RigidBody`.
     *
     * @remarks This property is Read-Only.
     */
    public LocalInertia: ManagedMath.Vector3;

    /**
     * The total forces affecting of the `RigidBody`.
     *
     * @remarks This property is Read-Only.
     */
    public TotalForce: ManagedMath.Vector3;

    /**
     * The total torque affecting of the `RigidBody`.
     *
     * @remarks This property is Read-Only.
     */
    public TotalTorque: ManagedMath.Vector3;

    /**
     * The mass of the `RigidBody`.
     *
     * @remarks This property is Read/Write.
     */
    public Mass: number;

    /**
     * A 32 bit bitwise mask representing what physical objects the `RigidBody` will collide with.
     * The `RigidBody` will collide with all physical objects that it shares at least a bit with.
     *
     * @remarks This property is Read/Write.
     */
    public CollisionMask: number;

    /**
     * Whether the `RigidBody` is a trigger.
     * Trigger rigidbodies detect collisions but don't react to them.
     *
     * @remarks This property is Read/Write.
     */
    public IsTrigger: boolean;

    /**
     * Whether the `RigidBody` is static.
     * Static rigidbodies can't move but still react to collisions.
     * Static rigidbodies can be concave.
     *
     * @remarks This property is Read/Write.
     */
    public IsStatic: boolean;

    /**
     * Whether the `RigidBody` is kinematic.
     * The movement of Kinematic rigidbodies is controlled by code (forces are not applied).
     * Kinematic rigidbodies detect collisions but don't react to them.
     *
     * @remarks This property is Read/Write.
     */
    public IsKinematic: boolean;

    /**
     * An `EventHandler` that fires when the `RigidBody` collides with another physics object.
     *
     * @remarks This property is Read-Only.
     */
    public OnCollide: EventHandler<(collisionData: CollisionData) => void>;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    public Id: string;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;

    /**
     * Applies a force to the `RigidBody` from its center of mass.
     *
     * @param force - The force to apply to the `RigidBody`.
     */
    public ApplyCentralForce(force: ManagedMath.Vector3): void;

    /**
     * Applies an impulse to the `RigidBody` from its center of mass.
     *
     * @param impulse - The impulse to apply to the `RigidBody`.
     */
    public ApplyCentralImpulse(impulse: ManagedMath.Vector3): void;

    /**
     * Applies damping to the `RigidBody`.
     *
     * @param timeStep - The time step to apply the damping over.
     */
    public ApplyDamping(timeStep: number): void;

    /**
     * Applies a force to the `RigidBody` from the specified relative position.
     *
     * @param force - The force to apply to the `RigidBody`.
     * @param relPos - The position to apply the force from.
     */
    public ApplyForce(force: ManagedMath.Vector3, relPos: ManagedMath.Vector3): void;

    /**
     * Applies gravity to the `RigidBody`.
     */
    public ApplyGravity(): void;

    /**
     * Applies an impulse to the `RigidBody` from the specified relative position.
     *
     * @param impulse - The impulse to apply to the `RigidBody`.
     * @param relPos - The position to apply the impulse from.
     */
    public ApplyImpulse(impulse: ManagedMath.Vector3, relPos: ManagedMath.Vector3): void;

    /**
     * Applies a torque to the `RigidBody`.
     *
     * @param torque - The torque to apply to the `RigidBody`.
     */
    public ApplyTorque(torque: ManagedMath.Vector3): void;

    /**
     * Applies a torque impulse to the `RigidBody`.
     *
     * @param torque - The torque to apply to the `RigidBody`.
     */
    public ApplyTorqueImpulse(torque: ManagedMath.Vector3): void;

    /**
     * Clears all the forces affecting the `RigidBody`.
     */
    public ClearForces(): void;

    /**
     * Returns the aabb bounds of the `RigidBody`.
     *
     * @returns The aabb bounds of the `RigidBody`.
     */
    public GetAabb(): ManagedMath.Aabb;

    /**
     * Instantly translates the `RigidBody` to the specified position.
     *
     * @param pos - The position to translate the `RigidBody` to.
     */
    public Translate(pos: ManagedMath.Vector3): void;
}

/**
 * Represents an Input Action.
 */
declare abstract class InputAction extends ManagedObject {
    /**
     * The name of the `InputAction`.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * A list of triggers that the `InputAction` will listen for.
     *
     * @remarks This property is Read-Only.
     */
    public Triggers: Array<InputActionTrigger>;

    /**
     * The current digital value of the `InputAction`.
     *
     * @remarks This property is Read-Only.
     */
    public DigitalValue: boolean;

    /**
     * The current analog value of the `InputAction`.
     *
     * @remarks This property is Read-Only.
     */
    public AnalogValue: number;

    /**
     * An `EventHandler` that fires when the action is digitally activated.
     *
     * @remarks This property is Read-Only.
     */
    public OnDigitalActivate: EventHandler<(inputAction: InputAction) => void>;

    /**
     * An `EventHandler` that fires when the action is digitally deactivated.
     *
     * @remarks This property is Read-Only.
     */
    public OnDigitalDeactivate: EventHandler<(inputAction: InputAction) => void>;

    /**
     * An `EventHandler` that fires when the action's digital value changes'.
     *
     * @remarks This property is Read-Only.
     */
    public OnDigitalUpdate: EventHandler<(inputAction: InputAction, value: boolean) => void>;

    /**
     * An `EventHandler` that fires when the action's analog value changes'.
     *
     * @remarks This property is Read-Only.
     */
    public OnAnalogUpdate: EventHandler<(inputAction: InputAction, value: number) => void>;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * Adds a keyboard trigger to the `InputAction`.
     *
     * @param scanCode - The scan code of the key the trigger will listen for.
     * @param analogContribution - The value the trigger will apply to analog actions when activated.
     * @returns The added keyboard trigger.
     */
    public AddKeyboardTrigger(scanCode: KeyboardScanCode, analogContribution: number): KeyboardActionTrigger;

    /**
     * Adds a gamepad button trigger to the `InputAction`.
     *
     * @param scanCode - The scan code of the gamepad button the trigger will listen for.
     * @param gamePadIndex - The index of the gamepad the trigger will listen for.
     * @param analogContribution - The value the trigger will apply to analog actions when activated.
     * @returns The added gamepad button trigger.
     */
    public AddGamePadButtonTrigger(scanCode: GamePadButtonScanCode, gamePadIndex: number, analogContribution: number): GamePadButtonActionTrigger;

    /**
     * Adds a gamepad axis trigger to the `InputAction`.
     *
     * @param scanCode - The scan code of the gamepad axis the trigger will listen for.
     * @param gamePadIndex - The index of the gamepad the trigger will listen for.
     * @param digitalActivationThereshold - The thereshold value after which the trigger will activate digital actions.
     * @param deadZone - The dead zone [0-1] area inside which the trigger will be ignored.
     * @param invert - Whether the value of the trigger will be inverted.
     * @returns The added gamepad axis trigger.
     */
    public AddGamePadAxisTrigger(scanCode: GamePadAxisScanCode, gamePadIndex: number, digitalActivationThereshold: number, deadZone: number, invert: boolean): GamePadAxisActionTrigger;

    /**
     * Removes a trigger from the `InputAction`.
     *
     * @param trigger - The trigger to remove.
     */
    public RemoveTrigger(trigger: InputActionTrigger): void;

    /**
     * Removes all triggers from the `InputAction`.
     */
    public ClearTriggers(): void;
}

/**
 * Represents an Analog Input Action Trigger.
 */
declare abstract class InputActionTriggerAnalog extends InputActionTrigger {
    /**
     * The value of the Input Action Trigger.
     *
     * @remarks This property is Read-Only.
     */
    public TriggerValue: number;

    /**
     * The thereshold value after which the Input Action Trigger will activate digital actions.
     *
     * @remarks This property is Read/Write.
     */
    public DigitalActivationThereshold: number;

    /**
     * The dead zone [0-1] area inside which the trigger will be ignored.
     *
     * @remarks This property is Read/Write.
     */
    public DeadZone: number;

    /**
     * Whether the value of the trigger will be inverted.
     *
     * @remarks This property is Read/Write.
     */
    public Invert: boolean;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;
}

/**
 * Represents a Digital Input Action Trigger.
 */
declare abstract class InputActionTriggerDigital extends InputActionTrigger {
    /**
     * The value of the Input Action Trigger.
     *
     * @remarks This property is Read-Only.
     */
    public TriggerValue: boolean;

    /**
     * The value the trigger will apply to analog actions when activated.
     *
     * @remarks This property is Read/Write.
     */
    public AnalogContribution: number;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;
}

/**
 * Represents an Input Action Trigger.
 */
declare abstract class InputActionTrigger extends ManagedObject {
    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;
}

/**
 * Represents a Keyboard Input Action Trigger.
 */
declare class KeyboardActionTrigger extends InputActionTriggerDigital {
    /**
     * The scan code of the key the action will listen for.
     *
     * @remarks This property is Read-Only.
     */
    public ScanCode: KeyboardScanCode;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;
}

/**
 * Represents a GamePad Axis Input Action Trigger.
 */
declare class GamePadAxisActionTrigger extends InputActionTriggerAnalog {
    /**
     * The scan code of the button the action trigger will listen for.
     *
     * @remarks This property is Read-Only.
     */
    public ScanCode: GamePadAxisScanCode;

    /**
     * The index of the gamepad the action trigger will listen for.
     *
     * @remarks This property is Read-Only.
     */
    public GamePadIndex: number;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;
}

/**
 * Represents a GamePad Button Input Action Trigger.
 */
declare class GamePadButtonActionTrigger extends InputActionTriggerDigital {
    /**
     * The scan code of the button the action trigger will listen for.
     *
     * @remarks This property is Read-Only.
     */
    public ScanCode: GamePadButtonScanCode;

    /**
     * The index of the gamepad the action trigger will listen for.
     *
     * @remarks This property is Read-Only.
     */
    public GamePadIndex: number;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;
}

/**
 * Represents a GameObject.
 */
declare class GameObject extends ManagedObject implements IActivable, INameable, ITransformable, IComponentable, IParentable {
    /**
     * The transform of the `GameObject`.
     *
     * @remarks This property is Read-Only.
     */
    public Transform: Transform;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The transform of the object in world space.
     * This property takes into account the transforms of the parents of the object.
     * Changing the values returned by this property has no effect as the world space transform is calculated on demand.
     *
     * @remarks This property is Read-Only.
     */
    public WorldSpaceTransform: Transform;

    /**
     * A list of all the components attached to the object.
     *
     * @remarks This property is Read-Only.
     */
    public Components: Array<IComponent>;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;

    /**
     * Attaches a component to the object.
     *
     * @param component - The component to attach.
     */
    public AttachComponent(component: IComponent): void;

    /**
     * Attaches a list of components to the object.
     *
     * @param components - The list of components to attach.
     */
    public AttachComponents(components: Array<IComponent>): void;

    /**
     * Removes a component from the object.
     *
     * @param component - The component to remove.
     */
    public RemoveComponent(component: IComponent): void;

    /**
     * Removes a list of components from the object.
     *
     * @param components - The list of components to remove.
     */
    public RemoveComponents(components: Array<IComponent>): void;
}

/**
 * Represents a Camera Component.
 */
declare abstract class Camera extends ManagedObject implements IComponent, ITransformable {
    /**
     * The transform of the `Camera`.
     *
     * @remarks This property is Read-Only.
     */
    public Transform: Transform;

    /**
     * The near value determines the minimal distance between the `Camera` and a `Sprite2D`.
     * If a `Sprite2D` is closer to the camera than this distance, the `Sprite2D` is clipped and does not appear.
     *
     * @remarks This property is Read/Write.
     */
    public ZNear: number;

    /**
     * The far value determines the maximal distance between the `Camera` and a `Sprite2D`.
     * If a `Sprite2D` is farther from the `Camera` than this distance, the `Sprite2D` is clipped and does not appear.
     *
     * @remarks This property is Read/Write.
     */
    public ZFar: number;

    /**
     * The list of drawables the camera will render.
     *
     * @remarks This property is Read-Only.
     */
    public Drawables: Array<IDrawable>;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    public Id: string;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;

    /**
     * The transform of the object in world space.
     * This property takes into account the transforms of the parents of the object.
     * Changing the values returned by this property has no effect as the world space transform is calculated on demand.
     *
     * @remarks This property is Read-Only.
     */
    public WorldSpaceTransform: Transform;

    /**
     * Adds a drawable to the list of drawables the camera will render.
     *
     * @param drawable - The drawable to add.
     */
    public AddDrawable(drawable: IDrawable): void;

    /**
     * Removes a drawable to the list of drawables the camera will render.
     *
     * @param drawable - The drawable to remove.
     */
    public RemoveDrawable(drawable: IDrawable): void;
}

/**
 * Represents an Orthographic Camera Component.
 */
declare class OrthographicCamera extends Camera {
    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    public Id: string;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;

    /**
     * The transform of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Transform: Transform;

    /**
     * The transform of the object in world space.
     * This property takes into account the transforms of the parents of the object.
     * Changing the values returned by this property has no effect as the world space transform is calculated on demand.
     *
     * @remarks This property is Read-Only.
     */
    public WorldSpaceTransform: Transform;

    /**
     * Constructor.
     */
    constructor();

    /**
     * Constructor.
     *
     * @param position - The target position of the `OrthographicCamera`.
     */
    constructor(position: ManagedMath.Vector3);

    /**
     * Constructor.
     *
     * @param position - The target position of the `OrthographicCamera`.
     * @param rotation - The target rotation of the `OrthographicCamera`.
     */
    constructor(position: ManagedMath.Vector3, rotation: ManagedMath.Quaternion);
}

/**
 * Represents a Perspective Camera Component.
 */
declare class PerspectiveCamera extends Camera {
    /**
     * The vertical viewing angle of the `PerspectiveCamera` (in radians).
     *
     * @remarks This property is Read/Write.
     */
    public FieldOfView: number;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    public Id: string;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;

    /**
     * The transform of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Transform: Transform;

    /**
     * The transform of the object in world space.
     * This property takes into account the transforms of the parents of the object.
     * Changing the values returned by this property has no effect as the world space transform is calculated on demand.
     *
     * @remarks This property is Read-Only.
     */
    public WorldSpaceTransform: Transform;

    /**
     * Constructor.
     */
    constructor();

    /**
     * Constructor.
     *
     * @param position - The target position of the `PerspectiveCamera`.
     */
    constructor(position: ManagedMath.Vector3);

    /**
     * Constructor.
     *
     * @param position - The target position of the `PerspectiveCamera`.
     * @param rotation - The target rotation of the `PerspectiveCamera`.
     */
    constructor(position: ManagedMath.Vector3, rotation: ManagedMath.Quaternion);
}

/**
 * Represents an Animated Sprite Component.
 */
declare class AnimatedSprite extends ManagedObject implements IComponent, IDrawable {
    /**
     * The transform of the `AnimatedSprite`.
     *
     * @remarks This property is Read-Only.
     */
    public Transform: Transform;

    /**
     * The `AnimatedMaterial` used to render the `AnimatedSprite`.
     *
     * @remarks This property is Read/Write.
     */
    public Material: AnimatedMaterial;

    /**
     * The `ShaderProgram` used to render the `AnimatedSprite`.
     *
     * @remarks This property is Read/Write.
     */
    public ShaderProgram: ShaderProgram;

    /**
     * The current frame of the `AnimatedSprite`.
     * This value corresponds to one of the frame indices of the active `TextureBundle`.
     * WARNING: Changing the frame causes a GPU buffering operation, this property should only be updated from `onRender`.
     *
     * @remarks This property is Read/Write.
     */
    public Frame: number;

    /**
     * The total amount of frames present on the active `AnimatedMaterial`.
     * WARNING: This property is the total AMOUNT of frames, NOT the last index.
     *
     * @remarks This property is Read-Only.
     */
    public FrameCount: number;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    public Id: string;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;

    /**
     * Whether the `IDrawable` should be drawn to screen.
     * Setting this property to `false` does NOT unload the `IDrawable` from memory.
     * Using this property is significantly faster than (de)activating the `IDrawable` and should be preferred over (de)activation for animation.
     * Most `IDrawable` will default to `true` unless this property has explicitly been set before activating them.
     *
     * @remarks This property is Read/Write.
     */
    public ShouldDraw: boolean;

    /**
     * The transform of the object in world space.
     * This property takes into account the transforms of the parents of the object.
     * Changing the values returned by this property has no effect as the world space transform is calculated on demand.
     *
     * @remarks This property is Read-Only.
     */
    public WorldSpaceTransform: Transform;

    /**
     * Constructor.
     *
     * @param textureName - The name of the resource of the `TextureBundle` to use for the `AnimatedSprite`.
     * @param shaderProgramName - The name of the resource of the `ShaderProgram` to use for the `AnimatedSprite`.
     */
    constructor(textureName: string, shaderProgramName: string);

    /**
     * Constructor.
     *
     * @param textureName - The name of the resource of the `TextureBundle` to use for the `AnimatedSprite`.
     * @param shaderProgramName - The name of the resource of the `ShaderProgram` to use for the `AnimatedSprite`.
     * @param position - The target position of the `AnimatedSprite`.
     * @param rotation - The target rotation of the `AnimatedSprite`.
     */
    constructor(textureName: string, shaderProgramName: string, position: ManagedMath.Vector3, rotation: ManagedMath.Quaternion);

    /**
     * Constructor.
     *
     * @param textureName - The name of the resource of the `TextureBundle` to use for the `AnimatedSprite`.
     * @param shaderProgramName - The name of the resource of the `ShaderProgram` to use for the `AnimatedSprite`.
     * @param position - The target position of the `AnimatedSprite`.
     */
    constructor(textureName: string, shaderProgramName: string, position: ManagedMath.Vector3);

    /**
     * Constructor.
     *
     * @param materialName - The name of the resource of the `AnimatedMaterial` to use for the `AnimatedSprite`.
     * @param shaderProgramName - The name of the resource of the `ShaderProgram` to use for the `AnimatedSprite`.
     * @param position - The target position of the `AnimatedSprite`.
     * @param rotation - The target rotation of the `AnimatedSprite`.
     * @param scale - The target scale of the `AnimatedSprite`.
     */
    constructor(materialName: string, shaderProgramName: string, position: ManagedMath.Vector3, rotation: ManagedMath.Quaternion, scale: ManagedMath.Vector3);
}

/**
 * Represents an Animated Material Component.
 */
declare abstract class AnimatedMaterial extends ManagedObject implements IComponent {
    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * The Id of the resource the component was created from or null if the component type does not use resources.
     *
     * @remarks This property is Read-Only.
     */
    public Id: string;

    /**
     * The active status of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Active: boolean;

    /**
     * The active status of the object in the inheritance graph.
     * `true` if the object and all its parents to the top of the inheritance graph are active, `false` otherwise.
     *
     * @remarks This property is Read-Only.
     */
    public ActiveInGraph: boolean;

    /**
     * The name of the object.
     *
     * @remarks This property is Read/Write.
     */
    public Name: string;

    /**
     * The parent of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Parent: GameObject | Scene;
}

/**
 * Represents a Tween Component that can update references to fields and/or properties over time.
 */
declare class Tween extends ManagedObject {
    /**
     * An `EventHandler` that fires when the tweening operation is finished.
     *
     * @remarks This property is Read-Only.
     */
    public OnEnd: EventHandler<() => void>;

    /**
     * The Managed Type of the object.
     *
     * @remarks This property is Read-Only.
     */
    public Type: ManagedObjectType;

    /**
     * Constructor.
     *
     * @param easeType - The ease type the `Tween` will use to interpolate.
     * @param targetTime - The target time in milliseconds the `Tween` will take to complete.
     * @param sourceObject - The object to perform the tweening operation on. It must not be a value type.
     * @param values - An object containing the members of the `sourceObject` that the `Tween` will update.
     */
    constructor(easeType: TweenEaseType, targetTime: number, sourceObject: any, values: any);

    /**
     * Runs the `Tween`.
     *
     * @param context - The context the tween will run on.
     */
    public Run(context: CoroutineContext): void;
}

/**
 * Represents the keys of a Keyboard.
 */
declare enum KeyboardScanCode {
    /**
     * Unsupported key.
     */
    Unsupported = 0,

    /**
     * To be documented.
     */
    A = 1,

    /**
     * To be documented.
     */
    B = 2,

    /**
     * To be documented.
     */
    C = 3,

    /**
     * To be documented.
     */
    D = 4,

    /**
     * To be documented.
     */
    E = 5,

    /**
     * To be documented.
     */
    F = 6,

    /**
     * To be documented.
     */
    G = 7,

    /**
     * To be documented.
     */
    H = 8,

    /**
     * To be documented.
     */
    I = 9,

    /**
     * To be documented.
     */
    J = 10,

    /**
     * To be documented.
     */
    K = 11,

    /**
     * To be documented.
     */
    L = 12,

    /**
     * To be documented.
     */
    M = 13,

    /**
     * To be documented.
     */
    N = 14,

    /**
     * To be documented.
     */
    O = 15,

    /**
     * To be documented.
     */
    P = 16,

    /**
     * To be documented.
     */
    Q = 17,

    /**
     * To be documented.
     */
    R = 18,

    /**
     * To be documented.
     */
    S = 19,

    /**
     * To be documented.
     */
    T = 20,

    /**
     * To be documented.
     */
    U = 21,

    /**
     * To be documented.
     */
    V = 22,

    /**
     * To be documented.
     */
    W = 23,

    /**
     * To be documented.
     */
    X = 24,

    /**
     * To be documented.
     */
    Y = 25,

    /**
     * To be documented.
     */
    Z = 26,

    /**
     * To be documented.
     */
    Alpha0 = 27,

    /**
     * To be documented.
     */
    Alpha1 = 28,

    /**
     * To be documented.
     */
    Alpha2 = 29,

    /**
     * To be documented.
     */
    Alpha3 = 30,

    /**
     * To be documented.
     */
    Alpha4 = 31,

    /**
     * To be documented.
     */
    Alpha5 = 32,

    /**
     * To be documented.
     */
    Alpha6 = 33,

    /**
     * To be documented.
     */
    Alpha7 = 34,

    /**
     * To be documented.
     */
    Alpha8 = 35,

    /**
     * To be documented.
     */
    Alpha9 = 36,

    /**
     * To be documented.
     */
    Numpad0 = 37,

    /**
     * To be documented.
     */
    Numpad1 = 38,

    /**
     * To be documented.
     */
    Numpad2 = 39,

    /**
     * To be documented.
     */
    Numpad3 = 40,

    /**
     * To be documented.
     */
    Numpad4 = 41,

    /**
     * To be documented.
     */
    Numpad5 = 42,

    /**
     * To be documented.
     */
    Numpad6 = 43,

    /**
     * To be documented.
     */
    Numpad7 = 44,

    /**
     * To be documented.
     */
    Numpad8 = 45,

    /**
     * To be documented.
     */
    Numpad9 = 46,

    /**
     * To be documented.
     */
    NumpadPlus = 47,

    /**
     * To be documented.
     */
    NumpadMinus = 48,

    /**
     * To be documented.
     */
    NumpadDiv = 49,

    /**
     * To be documented.
     */
    NumpadMult = 50,

    /**
     * To be documented.
     */
    NumpadPeriod = 51,

    /**
     * To be documented.
     */
    NumpadEnter = 52,

    /**
     * To be documented.
     */
    Return = 53,

    /**
     * To be documented.
     */
    Escape = 54,

    /**
     * To be documented.
     */
    Backspace = 55,

    /**
     * To be documented.
     */
    Tab = 56,

    /**
     * To be documented.
     */
    Space = 57,

    /**
     * To be documented.
     */
    Minus = 58,

    /**
     * To be documented.
     */
    EqualsKey = 59,

    /**
     * To be documented.
     */
    LeftBracket = 60,

    /**
     * To be documented.
     */
    RightBracket = 61,

    /**
     * To be documented.
     */
    Backslash = 62,

    /**
     * To be documented.
     */
    InternationalHash = 63,

    /**
     * To be documented.
     */
    Semicolon = 64,

    /**
     * To be documented.
     */
    Apostrophe = 65,

    /**
     * To be documented.
     */
    Grave = 66,

    /**
     * To be documented.
     */
    Comma = 67,

    /**
     * To be documented.
     */
    Period = 68,

    /**
     * To be documented.
     */
    Slash = 69,

    /**
     * To be documented.
     */
    Capslock = 70,

    /**
     * To be documented.
     */
    F1 = 71,

    /**
     * To be documented.
     */
    F2 = 72,

    /**
     * To be documented.
     */
    F3 = 73,

    /**
     * To be documented.
     */
    F4 = 74,

    /**
     * To be documented.
     */
    F5 = 75,

    /**
     * To be documented.
     */
    F6 = 76,

    /**
     * To be documented.
     */
    F7 = 77,

    /**
     * To be documented.
     */
    F8 = 78,

    /**
     * To be documented.
     */
    F9 = 79,

    /**
     * To be documented.
     */
    F10 = 80,

    /**
     * To be documented.
     */
    F11 = 81,

    /**
     * To be documented.
     */
    F12 = 82,

    /**
     * To be documented.
     */
    F13 = 83,

    /**
     * To be documented.
     */
    F14 = 84,

    /**
     * To be documented.
     */
    F15 = 85,

    /**
     * To be documented.
     */
    F16 = 86,

    /**
     * To be documented.
     */
    F17 = 87,

    /**
     * To be documented.
     */
    F18 = 88,

    /**
     * To be documented.
     */
    F19 = 89,

    /**
     * To be documented.
     */
    F20 = 90,

    /**
     * To be documented.
     */
    F21 = 91,

    /**
     * To be documented.
     */
    F22 = 92,

    /**
     * To be documented.
     */
    F23 = 93,

    /**
     * To be documented.
     */
    F24 = 94,

    /**
     * To be documented.
     */
    PrintScreen = 95,

    /**
     * To be documented.
     */
    ScrollLock = 96,

    /**
     * To be documented.
     */
    Pause = 97,

    /**
     * To be documented.
     */
    Insert = 98,

    /**
     * To be documented.
     */
    Home = 99,

    /**
     * To be documented.
     */
    PageUp = 100,

    /**
     * To be documented.
     */
    Delete = 101,

    /**
     * To be documented.
     */
    End = 102,

    /**
     * To be documented.
     */
    PageDown = 103,

    /**
     * To be documented.
     */
    ArrowRight = 104,

    /**
     * To be documented.
     */
    ArrowLeft = 105,

    /**
     * To be documented.
     */
    ArrowDown = 106,

    /**
     * To be documented.
     */
    ArrowUp = 107,

    /**
     * To be documented.
     */
    NumLock = 108,

    /**
     * To be documented.
     */
    InternationalBackslash = 109,

    /**
     * To be documented.
     */
    MediaApplication = 110,

    /**
     * To be documented.
     */
    MediaPower = 111,

    /**
     * To be documented.
     */
    NumpadEquals = 112,

    /**
     * To be documented.
     */
    MediaExecute = 113,

    /**
     * To be documented.
     */
    MediaHelp = 114,

    /**
     * To be documented.
     */
    Menu = 115,

    /**
     * To be documented.
     */
    MediaSelect = 116,

    /**
     * To be documented.
     */
    MediaStop = 117,

    /**
     * To be documented.
     */
    MediaAgain = 118,

    /**
     * To be documented.
     */
    MediaUndo = 119,

    /**
     * To be documented.
     */
    MediaCut = 120,

    /**
     * To be documented.
     */
    MediaCopy = 121,

    /**
     * To be documented.
     */
    MediaPaste = 122,

    /**
     * To be documented.
     */
    MediaFind = 123,

    /**
     * To be documented.
     */
    MediaMute = 124,

    /**
     * To be documented.
     */
    MediaVolumeUp = 125,

    /**
     * To be documented.
     */
    MediaVolumeDown = 126,

    /**
     * To be documented.
     */
    International1 = 127,

    /**
     * To be documented.
     */
    International2 = 128,

    /**
     * To be documented.
     */
    International3 = 129,

    /**
     * To be documented.
     */
    International4 = 130,

    /**
     * To be documented.
     */
    International5 = 131,

    /**
     * To be documented.
     */
    International6 = 132,

    /**
     * To be documented.
     */
    International7 = 133,

    /**
     * To be documented.
     */
    International8 = 134,

    /**
     * To be documented.
     */
    International9 = 135,

    /**
     * To be documented.
     */
    Colon = 136,

    /**
     * To be documented.
     */
    CurrencySymbol = 137,

    /**
     * To be documented.
     */
    CurrencySubSymbol = 138,

    /**
     * To be documented.
     */
    LeftControl = 139,

    /**
     * To be documented.
     */
    LeftShift = 140,

    /**
     * To be documented.
     */
    LeftAlt = 141,

    /**
     * To be documented.
     */
    LeftOsKey = 142,

    /**
     * To be documented.
     */
    RightControl = 143,

    /**
     * To be documented.
     */
    RightShift = 144,

    /**
     * To be documented.
     */
    RightAlt = 145,

    /**
     * To be documented.
     */
    RightOsKey = 146,

    /**
     * To be documented.
     */
    Mode = 147,

    /**
     * To be documented.
     */
    MediaNext = 148,

    /**
     * To be documented.
     */
    MediaPrev = 149,

    /**
     * To be documented.
     */
    MediaPlay = 150,

    /**
     * To be documented.
     */
    MediaWeb = 151,

    /**
     * To be documented.
     */
    MediaMail = 152,

    /**
     * To be documented.
     */
    MediaCalculator = 153,

    /**
     * To be documented.
     */
    MediaComputer = 154,
}

/**
 * Represents the axes of a GamePad.
 */
declare enum GamePadAxisScanCode {
    /**
     * Unsupported axis.
     */
    Unsupported = 0,

    /**
     * Left stick X axis.
     */
    LeftX = 1,

    /**
     * Left stick Y axis.
     */
    LeftY = 2,

    /**
     * Right stick X axis.
     */
    RightX = 3,

    /**
     * Right stick Y axis.
     */
    RightY = 4,

    /**
     * L2 (left trigger) axis.
     */
    L2 = 5,

    /**
     * R2 (right trigger) axis.
     */
    R2 = 6,
}

/**
 * Represents the buttons of a GamePad.
 */
declare enum GamePadButtonScanCode {
    /**
     * Unsupported button.
     */
    Unsupported = 0,

    /**
     * A button.
     */
    A = 1,

    /**
     * B button.
     */
    B = 2,

    /**
     * X button.
     */
    X = 3,

    /**
     * Y button.
     */
    Y = 4,

    /**
     * Back button.
     */
    Back = 5,

    /**
     * Guide/Select button.
     */
    Guide = 6,

    /**
     * Start button.
     */
    Start = 7,

    /**
     * L3 (left stick click) button.
     */
    L3 = 8,

    /**
     * R3 (right stick click) button.
     */
    R3 = 9,

    /**
     * L1 (left shoulder) button.
     */
    L1 = 10,

    /**
     * R1 (right shoulder) button.
     */
    R1 = 11,

    /**
     * Up (dpad) button.
     */
    Up = 12,

    /**
     * Down (dpad) button.
     */
    Down = 13,

    /**
     * Left (dpad) button.
     */
    Left = 14,

    /**
     * Right (dpad) button.
     */
    Right = 15,
}

/**
 * Represents the managed types wrapped by `IManagedWrapper`.
 */
declare enum ManagedObjectType {
    /**
     * Camera Component. Includes all projection types.
     */
    Camera = 0,

    /**
     * Texture Component.
     */
    Texture = 1,

    /**
     * Material Component.
     */
    Material = 2,

    /**
     * Shader Component.
     */
    Shader = 3,

    /**
     * ShaderProgram Component.
     */
    ShaderProgram = 4,

    /**
     * SoundBank Component.
     */
    SoundBank = 5,

    /**
     * Sound Component.
     */
    Sound = 6,

    /**
     * Script Component.
     */
    Script = 7,

    /**
     * Sprite2D Component.
     */
    Sprite2D = 8,

    /**
     * TextSprite Component.
     */
    TextSprite = 9,

    /**
     * RigidBody Component.
     */
    RigidBody = 10,

    /**
     * Transform Object.
     */
    Transform = 11,

    /**
     * GameObject Object.
     */
    GameObject = 12,

    /**
     * Scene Object.
     */
    Scene = 13,

    /**
     * EventHandler Object.
     */
    EventHandler = 14,

    /**
     * Vector2 Object.
     */
    Vector2 = 15,

    /**
     * Vector3 Object.
     */
    Vector3 = 16,

    /**
     * Vector4 Object.
     */
    Vector4 = 17,

    /**
     * Quaternion Object.
     */
    Quaternion = 18,

    /**
     * Aabb Object.
     */
    Aabb = 19,

    /**
     * CollisionData Object.
     */
    CollisionData = 20,

    /**
     * Tween Component.
     */
    Tween = 21,

    /**
     * Input Action.
     */
    InputAction = 22,

    /**
     * Input Action Digital Trigger.
     */
    InputActionTriggerDigital = 23,

    /**
     * Input Action Analog Trigger.
     */
    InputActionTriggerAnalog = 24,
}

/**
 * Represents how text should be drawn on the horizontal axis.
 */
declare enum TextAlignmentHorizontal {
    /**
     * The text should be drawn starting from the leftmost point of its bounding box.
     * The text will overflow to the right side of its bounding box from this point until it spans the entirety of the bounding box's width or
     * the line ends.
     */
    HLeft = 0,

    /**
     * The text should be drawn at the center of its bounding box.
     * The text will overflow to both sides of its bounding box from this point until it spans the entirety of the bounding box's width or all the
     * characters of the line have been drawn.
     */
    HCenter = 1,

    /**
     * The text should be drawn starting from the rightmost point of its bounding box.
     * The text will overflow to the left side of its bounding box from this point until it spans the entirety of the bounding box's width or
     * the line ends.
     */
    HRight = 2,
}

/**
 * Represents how text should be drawn on the vertical axis.
 */
declare enum TextAlignmentHorizontal {
    /**
     * The text should be drawn starting from the topmost point of its bounding box.
     * The text will overflow to the bottom side of its bounding box from this point until it spans the entirety of the bounding box's height or
     * all lines have been drawn.
     */
    VTop = 3,

    /**
     * The text should be drawn at the center of its bounding box.
     * The text will overflow to both the bottom and the top of its bounding box from this point until it spans the entirety of the bounding box's height
     * or all lines have been drawn.
     */
    VCenter = 4,

    /**
     * The text should be drawn starting from the bottom most point of its bounding box.
     * The text will overflow to the top side of its bounding box from this point until it spans the entirety of the bounding box's height or
     * all lines have been drawn.
     */
    VBottom = 5,
}

/**
 * Represents the playback status of a `Sound`.
 */
declare enum SoundPlaybackStatus {
    /**
     * The playback status cannot be retrieved or querying this property is not supported by the current sound engine.
     */
    Error = -1,

    /**
     * Playing.
     */
    Playing = 0,

    /**
     * Sustaining. The meaning of this status depends on the sound engine being used.
     */
    Sustaining = 1,

    /**
     * Stopped.
     */
    Stopped = 2,

    /**
     * Starting. The meaning of this status depends on the sound engine being used.
     */
    Starting = 3,

    /**
     * Stopping. The meaning of this status depends on the sound engine being used.
     */
    Stopping = 4,
}

/**
 * Represents the context a coroutine will run on.
 */
declare enum CoroutineContext {
    /**
     * The couroutine should be run by the scripting engine.
     */
    Script = 0,

    /**
     * The couroutine should be run by the rendering engine.
     */
    Render = 1,

    /**
     * The couroutine should be run by the physics engine.
     */
    Physics = 2,

    /**
     * The couroutine should be run by the sound engine.
     */
    Sound = 3,
}

/**
 * Represents the type of ease the tween will update.
 */
declare enum TweenEaseType {
    /**
     * Alias for `Linear`.
     */
    None = 0,

    /**
     * Linear easing.
     */
    Linear = 0,

    /**
     * Quadratic easing.
     */
    QuadraticIn = 1,

    /**
     * Quadratic easing.
     */
    QuadraticOut = 2,

    /**
     * Quadratic easing.
     */
    QuadraticInOut = 3,

    /**
     * Cubic easing.
     */
    CubicIn = 4,

    /**
     * Cubic easing.
     */
    CubicOut = 5,

    /**
     * Cubic easing.
     */
    CubicInOut = 6,

    /**
     * Quartic easing.
     */
    QuarticIn = 7,

    /**
     * Quartic easing.
     */
    QuarticOut = 8,

    /**
     * Quartic easing.
     */
    QuarticInOut = 9,

    /**
     * Quintic easing.
     */
    QuinticIn = 10,

    /**
     * Quintic easing.
     */
    QuinticOut = 11,

    /**
     * Quintic easing.
     */
    QuinticInOut = 12,

    /**
     * Sinusoidal easing.
     */
    SinusoidalIn = 13,

    /**
     * Sinusoidal easing.
     */
    SinusoidalOut = 14,

    /**
     * Sinusoidal easing.
     */
    SinusoidalInOut = 15,

    /**
     * Exponential easing.
     */
    ExponentialIn = 16,

    /**
     * Exponential easing.
     */
    ExponentialOut = 17,

    /**
     * Exponential easing.
     */
    ExponentialInOut = 18,

    /**
     * Circular easing.
     */
    CircularIn = 19,

    /**
     * Circular easing.
     */
    CircularOut = 20,

    /**
     * Circular easing.
     */
    CircularInOut = 21,

    /**
     * Elastic easing.
     */
    ElasticIn = 22,

    /**
     * Elastic easing.
     */
    ElasticOut = 23,

    /**
     * Elastic easing.
     */
    ElasticInOut = 24,

    /**
     * Back easing.
     */
    BackIn = 25,

    /**
     * Back easing.
     */
    BackOut = 26,

    /**
     * Back easing.
     */
    BackInOut = 27,

    /**
     * Bounce easing.
     */
    BounceIn = 28,

    /**
     * Bounce easing.
     */
    BounceOut = 29,

    /**
     * Bounce easing.
     */
    BounceInOut = 30,

    /**
     * Alias for `Linear`.
     */
    Power0 = 0,

    /**
     * Alias for `QuadraticOut`.
     */
    Power1 = 2,

    /**
     * Alias for `CubicOut`.
     */
    Power2 = 5,

    /**
     * Alias for `QuarticOut`.
     */
    Power3 = 8,

    /**
     * Alias for `QuinticOut`.
     */
    Power4 = 11,
}
